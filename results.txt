Excluding tags: [pending: true]

......................

  1) test Every other week on Monday, Wednesday and Friday until December 24, 1997, but starting on Tuesday, September 2, 1997: (Recur.IcalRruleTest)
     test/ical_rrul_test.exs:212
     Assertion with == failed
     code:  assert expect == result |> Enum.take(999)
     left:  [~D[1997-09-02], ~D[1997-09-03], ~D[1997-09-05], ~D[1997-09-15],
             ~D[1997-09-17], ~D[1997-09-19], ~D[1997-09-29], ~D[1997-10-01],
             ~D[1997-10-03], ~D[1997-10-13], ~D[1997-10-15], ~D[1997-10-17],
             ~D[1997-10-27], ~D[1997-10-29], ~D[1997-10-31], ~D[1997-11-10],
             ~D[1997-11-12], ~D[1997-11-14], ~D[1997-11-24], ~D[1997-11-26],
             ~D[1997-11-28], ~D[1997-12-08], ~D[1997-12-10], ~D[1997-12-12],
             ~D[1997-12-22], ~D[1997-12-24]]
     right: [~D[1997-09-03], ~D[1997-09-05], ~D[1997-09-08], ~D[1997-09-17],
             ~D[1997-09-19], ~D[1997-09-22], ~D[1997-10-01], ~D[1997-10-03],
             ~D[1997-10-06], ~D[1997-10-15], ~D[1997-10-17], ~D[1997-10-20],
             ~D[1997-10-29], ~D[1997-10-31], ~D[1997-11-03], ~D[1997-11-12],
             ~D[1997-11-14], ~D[1997-11-17], ~D[1997-11-26], ~D[1997-11-28],
             ~D[1997-12-01], ~D[1997-12-10], ~D[1997-12-12], ~D[1997-12-15],
             ~D[1997-12-24]]
     stacktrace:
       test/ical_rrul_test.exs:225: (test)

......................

  2) test with no count, until and interval it should stream forever (Recur.YearlyTest)
     test/recur/yearly_test.exs:22
     ** (ExUnit.TimeoutError) test timed out after 1000ms. You can change the timeout:
     
       1. per test by setting "@tag timeout: x"
       2. per case by setting "@moduletag timeout: x"
       3. globally via "ExUnit.start(timeout: x)" configuration
       4. or set it to infinity per run by calling "mix test --trace"
          (useful when using IEx.pry)
     
     Timeouts are given as integers in milliseconds.
     
     code: assert 96 == events |> Enum.take(96) |> Enum.count()
     stacktrace:
       (elixir) lib/float.ex:361: Float.decompose/6
       (elixir) lib/float.ex:221: Float.round/3
       (recurring_events) lib/recur/dates.ex:50: Dates.reverse_which_day_of_month/1
       (recurring_events) lib/recur/dates.ex:16: Dates.details/2
       (recurring_events) lib/recur/filter.ex:130: Recur.Filter.match/2
       (elixir) lib/stream.ex:429: anonymous fn/4 in Stream.filter/2
       (elixir) lib/stream.ex:1384: Stream.do_unfold/4
       (elixir) lib/stream.ex:1433: Enumerable.Stream.do_each/4
       (elixir) lib/enum.ex:2397: Enum.take/2
       test/recur/yearly_test.exs:26: (test)
       (ex_unit) lib/ex_unit/runner.ex:292: ExUnit.Runner.exec_test/1
       (stdlib) timer.erl:166: :timer.tc/1
       (ex_unit) lib/ex_unit/runner.ex:240: anonymous fn/3 in ExUnit.Runner.spawn_test/3

.............

  3) test can filter by month when frequency: :weekly (RecurTest.ByMonthTest)
     test/recur/by_month_test.exs:21
     Assertion with == failed
     code:  assert [] == Recur.unfold(%{start_date: @date, frequency: :weekly, by_month: [2, 5, 9]}) |> Enum.take(1)
     left:  []
     right: [~D[2017-02-03]]
     stacktrace:
       test/recur/by_month_test.exs:25: (test)



  4) test can filter by month when frequency: :daily (RecurTest.ByMonthTest)
     test/recur/by_month_test.exs:9
     Assertion with == failed
     code:  assert [] == Recur.unfold(%{start_date: @date, frequency: :daily, by_month: [2, 5, 9]}) |> Enum.take(1)
     left:  []
     right: [~D[2017-02-01]]
     stacktrace:
       test/recur/by_month_test.exs:13: (test)

...

  5) test can be inflate by year when frequency: yearly (Recur.ByDayTest)
     test/recur/by_day_test.exs:36
     Assertion with == failed
     code:  assert [~D"2017-01-06", ~D"2017-01-13", ~D"2017-01-20", ~D"2017-01-27", ~D"2017-02-03", ~D"2017-02-10", ~D"2017-02-17", ~D"2017-02-24", ~D"2017-03-03", ~D"2017-03-10", ~D"2017-03-17", ~D"2017-03-24", ~D"2017-03-31"] == Recur.unfold(%{start_date: @wednesday, frequency: :yearly, by_day: :friday}) |> Enum.take(13)
     left:  [~D[2017-01-06], ~D[2017-01-13], ~D[2017-01-20], ~D[2017-01-27],
             ~D[2017-02-03], ~D[2017-02-10], ~D[2017-02-17], ~D[2017-02-24],
             ~D[2017-03-03], ~D[2017-03-10], ~D[2017-03-17], ~D[2017-03-24],
             ~D[2017-03-31]]
     right: [~D[2017-01-27], ~D[2017-02-03], ~D[2017-02-10], ~D[2017-02-17],
             ~D[2017-02-24], ~D[2017-03-03], ~D[2017-03-10], ~D[2017-03-17],
             ~D[2017-03-24], ~D[2017-03-31], ~D[2017-04-07], ~D[2017-04-14],
             ~D[2017-04-21]]
     stacktrace:
       test/recur/by_day_test.exs:37: (test)



  6) test can be inflate by month when frequency: :monthly (Recur.ByDayTest)
     test/recur/by_day_test.exs:30
     Assertion with == failed
     code:  assert [~D"2017-01-04", ~D"2017-01-11", ~D"2017-01-18", @wednesday] == Recur.unfold(%{start_date: @wednesday, frequency: :monthly, by_day: :wednesday}) |> Enum.take(4)
     left:  [~D[2017-01-04], ~D[2017-01-11], ~D[2017-01-18], ~D[2017-01-25]]
     right: [~D[2017-01-25], ~D[2017-02-01], ~D[2017-02-08], ~D[2017-02-15]]
     stacktrace:
       test/recur/by_day_test.exs:31: (test)

..

  7) test can be inflate by month when by_month: is a single month (Recur.ByDayTest)
     test/recur/by_day_test.exs:55
     Assertion with == failed
     code:  assert @expected == Recur.unfold(%{start_date: @wednesday, frequency: :weekly, by_day: :wednesday, by_month: 2}) |> Enum.take(4)
     left:  [~D[2017-01-04], ~D[2017-01-11], ~D[2017-01-18], ~D[2017-01-25]]
     right: [~D[2017-02-01], ~D[2017-02-08], ~D[2017-02-15], ~D[2017-02-22]]
     stacktrace:
       test/recur/by_day_test.exs:56: (test)

.....

Finished in 2.4 seconds
76 tests, 7 failures, 2 skipped

Randomized with seed 565755
